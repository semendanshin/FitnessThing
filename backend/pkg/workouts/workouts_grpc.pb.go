// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.2
// source: workouts/workouts.proto

package workout

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ExerciseService_GetExercises_FullMethodName            = "/fitness_trainer.api.workout.ExerciseService/GetExercises"
	ExerciseService_CreateExercise_FullMethodName          = "/fitness_trainer.api.workout.ExerciseService/CreateExercise"
	ExerciseService_GetExerciseDetail_FullMethodName       = "/fitness_trainer.api.workout.ExerciseService/GetExerciseDetail"
	ExerciseService_GetExerciseAlternatives_FullMethodName = "/fitness_trainer.api.workout.ExerciseService/GetExerciseAlternatives"
	ExerciseService_GetExerciseHistory_FullMethodName      = "/fitness_trainer.api.workout.ExerciseService/GetExerciseHistory"
	ExerciseService_GetMuscleGroups_FullMethodName         = "/fitness_trainer.api.workout.ExerciseService/GetMuscleGroups"
)

// ExerciseServiceClient is the client API for ExerciseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExerciseServiceClient interface {
	// Метод для получения списка всех упражнений
	GetExercises(ctx context.Context, in *GetExercisesRequest, opts ...grpc.CallOption) (*GetExercisesResponse, error)
	// Метод для создания нового упражнения
	CreateExercise(ctx context.Context, in *CreateExerciseRequest, opts ...grpc.CallOption) (*ExerciseResponse, error)
	// Метод для получения деталей об упражнении
	GetExerciseDetail(ctx context.Context, in *GetExerciseDetailRequest, opts ...grpc.CallOption) (*ExerciseResponse, error)
	// Метод для получения альтернативных упражнений по exercise_id
	GetExerciseAlternatives(ctx context.Context, in *GetExerciseAlternativesRequest, opts ...grpc.CallOption) (*GetExerciseAlternativesResponse, error)
	// Метод для получения истории выполнения упражнения
	GetExerciseHistory(ctx context.Context, in *GetExerciseHistoryRequest, opts ...grpc.CallOption) (*ExerciseHistoryResponse, error)
	// Метод для получения списка групп мышц
	GetMuscleGroups(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetMuscleGroupsResponse, error)
}

type exerciseServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExerciseServiceClient(cc grpc.ClientConnInterface) ExerciseServiceClient {
	return &exerciseServiceClient{cc}
}

func (c *exerciseServiceClient) GetExercises(ctx context.Context, in *GetExercisesRequest, opts ...grpc.CallOption) (*GetExercisesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetExercisesResponse)
	err := c.cc.Invoke(ctx, ExerciseService_GetExercises_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) CreateExercise(ctx context.Context, in *CreateExerciseRequest, opts ...grpc.CallOption) (*ExerciseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExerciseResponse)
	err := c.cc.Invoke(ctx, ExerciseService_CreateExercise_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) GetExerciseDetail(ctx context.Context, in *GetExerciseDetailRequest, opts ...grpc.CallOption) (*ExerciseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExerciseResponse)
	err := c.cc.Invoke(ctx, ExerciseService_GetExerciseDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) GetExerciseAlternatives(ctx context.Context, in *GetExerciseAlternativesRequest, opts ...grpc.CallOption) (*GetExerciseAlternativesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetExerciseAlternativesResponse)
	err := c.cc.Invoke(ctx, ExerciseService_GetExerciseAlternatives_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) GetExerciseHistory(ctx context.Context, in *GetExerciseHistoryRequest, opts ...grpc.CallOption) (*ExerciseHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExerciseHistoryResponse)
	err := c.cc.Invoke(ctx, ExerciseService_GetExerciseHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) GetMuscleGroups(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetMuscleGroupsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMuscleGroupsResponse)
	err := c.cc.Invoke(ctx, ExerciseService_GetMuscleGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExerciseServiceServer is the server API for ExerciseService service.
// All implementations must embed UnimplementedExerciseServiceServer
// for forward compatibility.
type ExerciseServiceServer interface {
	// Метод для получения списка всех упражнений
	GetExercises(context.Context, *GetExercisesRequest) (*GetExercisesResponse, error)
	// Метод для создания нового упражнения
	CreateExercise(context.Context, *CreateExerciseRequest) (*ExerciseResponse, error)
	// Метод для получения деталей об упражнении
	GetExerciseDetail(context.Context, *GetExerciseDetailRequest) (*ExerciseResponse, error)
	// Метод для получения альтернативных упражнений по exercise_id
	GetExerciseAlternatives(context.Context, *GetExerciseAlternativesRequest) (*GetExerciseAlternativesResponse, error)
	// Метод для получения истории выполнения упражнения
	GetExerciseHistory(context.Context, *GetExerciseHistoryRequest) (*ExerciseHistoryResponse, error)
	// Метод для получения списка групп мышц
	GetMuscleGroups(context.Context, *emptypb.Empty) (*GetMuscleGroupsResponse, error)
	mustEmbedUnimplementedExerciseServiceServer()
}

// UnimplementedExerciseServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedExerciseServiceServer struct{}

func (UnimplementedExerciseServiceServer) GetExercises(context.Context, *GetExercisesRequest) (*GetExercisesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExercises not implemented")
}
func (UnimplementedExerciseServiceServer) CreateExercise(context.Context, *CreateExerciseRequest) (*ExerciseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateExercise not implemented")
}
func (UnimplementedExerciseServiceServer) GetExerciseDetail(context.Context, *GetExerciseDetailRequest) (*ExerciseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExerciseDetail not implemented")
}
func (UnimplementedExerciseServiceServer) GetExerciseAlternatives(context.Context, *GetExerciseAlternativesRequest) (*GetExerciseAlternativesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExerciseAlternatives not implemented")
}
func (UnimplementedExerciseServiceServer) GetExerciseHistory(context.Context, *GetExerciseHistoryRequest) (*ExerciseHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExerciseHistory not implemented")
}
func (UnimplementedExerciseServiceServer) GetMuscleGroups(context.Context, *emptypb.Empty) (*GetMuscleGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMuscleGroups not implemented")
}
func (UnimplementedExerciseServiceServer) mustEmbedUnimplementedExerciseServiceServer() {}
func (UnimplementedExerciseServiceServer) testEmbeddedByValue()                         {}

// UnsafeExerciseServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExerciseServiceServer will
// result in compilation errors.
type UnsafeExerciseServiceServer interface {
	mustEmbedUnimplementedExerciseServiceServer()
}

func RegisterExerciseServiceServer(s grpc.ServiceRegistrar, srv ExerciseServiceServer) {
	// If the following call pancis, it indicates UnimplementedExerciseServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ExerciseService_ServiceDesc, srv)
}

func _ExerciseService_GetExercises_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExercisesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).GetExercises(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_GetExercises_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).GetExercises(ctx, req.(*GetExercisesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_CreateExercise_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExerciseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).CreateExercise(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_CreateExercise_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).CreateExercise(ctx, req.(*CreateExerciseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_GetExerciseDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExerciseDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).GetExerciseDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_GetExerciseDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).GetExerciseDetail(ctx, req.(*GetExerciseDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_GetExerciseAlternatives_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExerciseAlternativesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).GetExerciseAlternatives(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_GetExerciseAlternatives_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).GetExerciseAlternatives(ctx, req.(*GetExerciseAlternativesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_GetExerciseHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExerciseHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).GetExerciseHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_GetExerciseHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).GetExerciseHistory(ctx, req.(*GetExerciseHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_GetMuscleGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).GetMuscleGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_GetMuscleGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).GetMuscleGroups(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ExerciseService_ServiceDesc is the grpc.ServiceDesc for ExerciseService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExerciseService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "fitness_trainer.api.workout.ExerciseService",
	HandlerType: (*ExerciseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetExercises",
			Handler:    _ExerciseService_GetExercises_Handler,
		},
		{
			MethodName: "CreateExercise",
			Handler:    _ExerciseService_CreateExercise_Handler,
		},
		{
			MethodName: "GetExerciseDetail",
			Handler:    _ExerciseService_GetExerciseDetail_Handler,
		},
		{
			MethodName: "GetExerciseAlternatives",
			Handler:    _ExerciseService_GetExerciseAlternatives_Handler,
		},
		{
			MethodName: "GetExerciseHistory",
			Handler:    _ExerciseService_GetExerciseHistory_Handler,
		},
		{
			MethodName: "GetMuscleGroups",
			Handler:    _ExerciseService_GetMuscleGroups_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "workouts/workouts.proto",
}

const (
	RoutineService_GetRoutines_FullMethodName                       = "/fitness_trainer.api.workout.RoutineService/GetRoutines"
	RoutineService_CreateRoutine_FullMethodName                     = "/fitness_trainer.api.workout.RoutineService/CreateRoutine"
	RoutineService_GetRoutineDetail_FullMethodName                  = "/fitness_trainer.api.workout.RoutineService/GetRoutineDetail"
	RoutineService_DeleteRoutine_FullMethodName                     = "/fitness_trainer.api.workout.RoutineService/DeleteRoutine"
	RoutineService_AddExerciseToRoutine_FullMethodName              = "/fitness_trainer.api.workout.RoutineService/AddExerciseToRoutine"
	RoutineService_RemoveExerciseInstanceFromRoutine_FullMethodName = "/fitness_trainer.api.workout.RoutineService/RemoveExerciseInstanceFromRoutine"
	RoutineService_AddSetToExerciseInstance_FullMethodName          = "/fitness_trainer.api.workout.RoutineService/AddSetToExerciseInstance"
	RoutineService_UpdateSetInExerciseInstance_FullMethodName       = "/fitness_trainer.api.workout.RoutineService/UpdateSetInExerciseInstance"
	RoutineService_RemoveSetFromExerciseInstance_FullMethodName     = "/fitness_trainer.api.workout.RoutineService/RemoveSetFromExerciseInstance"
)

// RoutineServiceClient is the client API for RoutineService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoutineServiceClient interface {
	// Метод для получения списка доступных пользователю рутин
	GetRoutines(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RoutineListResponse, error)
	// Создание новой рутины
	CreateRoutine(ctx context.Context, in *CreateRoutineRequest, opts ...grpc.CallOption) (*RoutineResponse, error)
	// Получение информации о рутине по ID
	GetRoutineDetail(ctx context.Context, in *GetRoutineDetailRequest, opts ...grpc.CallOption) (*RoutineDetailResponse, error)
	// Удаление рутины по ID
	DeleteRoutine(ctx context.Context, in *DeleteRoutineRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Добавление упражнения в рутину
	AddExerciseToRoutine(ctx context.Context, in *AddExerciseToRoutineRequest, opts ...grpc.CallOption) (*RoutineInstanceResponse, error)
	// Удаление упражнения из рутины
	RemoveExerciseInstanceFromRoutine(ctx context.Context, in *RemoveExerciseInstanceFromRoutineRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Метод для добавления сета в упражнение
	AddSetToExerciseInstance(ctx context.Context, in *AddSetToExerciseInstanceRequest, opts ...grpc.CallOption) (*SetResponse, error)
	// Метод для обновления сета в упражнении
	UpdateSetInExerciseInstance(ctx context.Context, in *UpdateSetInExerciseInstanceRequest, opts ...grpc.CallOption) (*SetResponse, error)
	// Метод для удаления сета из упражнения
	RemoveSetFromExerciseInstance(ctx context.Context, in *RemoveSetFromExerciseInstanceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type routineServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRoutineServiceClient(cc grpc.ClientConnInterface) RoutineServiceClient {
	return &routineServiceClient{cc}
}

func (c *routineServiceClient) GetRoutines(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RoutineListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoutineListResponse)
	err := c.cc.Invoke(ctx, RoutineService_GetRoutines_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routineServiceClient) CreateRoutine(ctx context.Context, in *CreateRoutineRequest, opts ...grpc.CallOption) (*RoutineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoutineResponse)
	err := c.cc.Invoke(ctx, RoutineService_CreateRoutine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routineServiceClient) GetRoutineDetail(ctx context.Context, in *GetRoutineDetailRequest, opts ...grpc.CallOption) (*RoutineDetailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoutineDetailResponse)
	err := c.cc.Invoke(ctx, RoutineService_GetRoutineDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routineServiceClient) DeleteRoutine(ctx context.Context, in *DeleteRoutineRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RoutineService_DeleteRoutine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routineServiceClient) AddExerciseToRoutine(ctx context.Context, in *AddExerciseToRoutineRequest, opts ...grpc.CallOption) (*RoutineInstanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoutineInstanceResponse)
	err := c.cc.Invoke(ctx, RoutineService_AddExerciseToRoutine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routineServiceClient) RemoveExerciseInstanceFromRoutine(ctx context.Context, in *RemoveExerciseInstanceFromRoutineRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RoutineService_RemoveExerciseInstanceFromRoutine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routineServiceClient) AddSetToExerciseInstance(ctx context.Context, in *AddSetToExerciseInstanceRequest, opts ...grpc.CallOption) (*SetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetResponse)
	err := c.cc.Invoke(ctx, RoutineService_AddSetToExerciseInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routineServiceClient) UpdateSetInExerciseInstance(ctx context.Context, in *UpdateSetInExerciseInstanceRequest, opts ...grpc.CallOption) (*SetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetResponse)
	err := c.cc.Invoke(ctx, RoutineService_UpdateSetInExerciseInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routineServiceClient) RemoveSetFromExerciseInstance(ctx context.Context, in *RemoveSetFromExerciseInstanceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RoutineService_RemoveSetFromExerciseInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoutineServiceServer is the server API for RoutineService service.
// All implementations must embed UnimplementedRoutineServiceServer
// for forward compatibility.
type RoutineServiceServer interface {
	// Метод для получения списка доступных пользователю рутин
	GetRoutines(context.Context, *emptypb.Empty) (*RoutineListResponse, error)
	// Создание новой рутины
	CreateRoutine(context.Context, *CreateRoutineRequest) (*RoutineResponse, error)
	// Получение информации о рутине по ID
	GetRoutineDetail(context.Context, *GetRoutineDetailRequest) (*RoutineDetailResponse, error)
	// Удаление рутины по ID
	DeleteRoutine(context.Context, *DeleteRoutineRequest) (*emptypb.Empty, error)
	// Добавление упражнения в рутину
	AddExerciseToRoutine(context.Context, *AddExerciseToRoutineRequest) (*RoutineInstanceResponse, error)
	// Удаление упражнения из рутины
	RemoveExerciseInstanceFromRoutine(context.Context, *RemoveExerciseInstanceFromRoutineRequest) (*emptypb.Empty, error)
	// Метод для добавления сета в упражнение
	AddSetToExerciseInstance(context.Context, *AddSetToExerciseInstanceRequest) (*SetResponse, error)
	// Метод для обновления сета в упражнении
	UpdateSetInExerciseInstance(context.Context, *UpdateSetInExerciseInstanceRequest) (*SetResponse, error)
	// Метод для удаления сета из упражнения
	RemoveSetFromExerciseInstance(context.Context, *RemoveSetFromExerciseInstanceRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedRoutineServiceServer()
}

// UnimplementedRoutineServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRoutineServiceServer struct{}

func (UnimplementedRoutineServiceServer) GetRoutines(context.Context, *emptypb.Empty) (*RoutineListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoutines not implemented")
}
func (UnimplementedRoutineServiceServer) CreateRoutine(context.Context, *CreateRoutineRequest) (*RoutineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRoutine not implemented")
}
func (UnimplementedRoutineServiceServer) GetRoutineDetail(context.Context, *GetRoutineDetailRequest) (*RoutineDetailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoutineDetail not implemented")
}
func (UnimplementedRoutineServiceServer) DeleteRoutine(context.Context, *DeleteRoutineRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRoutine not implemented")
}
func (UnimplementedRoutineServiceServer) AddExerciseToRoutine(context.Context, *AddExerciseToRoutineRequest) (*RoutineInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddExerciseToRoutine not implemented")
}
func (UnimplementedRoutineServiceServer) RemoveExerciseInstanceFromRoutine(context.Context, *RemoveExerciseInstanceFromRoutineRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveExerciseInstanceFromRoutine not implemented")
}
func (UnimplementedRoutineServiceServer) AddSetToExerciseInstance(context.Context, *AddSetToExerciseInstanceRequest) (*SetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSetToExerciseInstance not implemented")
}
func (UnimplementedRoutineServiceServer) UpdateSetInExerciseInstance(context.Context, *UpdateSetInExerciseInstanceRequest) (*SetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSetInExerciseInstance not implemented")
}
func (UnimplementedRoutineServiceServer) RemoveSetFromExerciseInstance(context.Context, *RemoveSetFromExerciseInstanceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveSetFromExerciseInstance not implemented")
}
func (UnimplementedRoutineServiceServer) mustEmbedUnimplementedRoutineServiceServer() {}
func (UnimplementedRoutineServiceServer) testEmbeddedByValue()                        {}

// UnsafeRoutineServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoutineServiceServer will
// result in compilation errors.
type UnsafeRoutineServiceServer interface {
	mustEmbedUnimplementedRoutineServiceServer()
}

func RegisterRoutineServiceServer(s grpc.ServiceRegistrar, srv RoutineServiceServer) {
	// If the following call pancis, it indicates UnimplementedRoutineServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RoutineService_ServiceDesc, srv)
}

func _RoutineService_GetRoutines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineServiceServer).GetRoutines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutineService_GetRoutines_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineServiceServer).GetRoutines(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutineService_CreateRoutine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRoutineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineServiceServer).CreateRoutine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutineService_CreateRoutine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineServiceServer).CreateRoutine(ctx, req.(*CreateRoutineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutineService_GetRoutineDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoutineDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineServiceServer).GetRoutineDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutineService_GetRoutineDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineServiceServer).GetRoutineDetail(ctx, req.(*GetRoutineDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutineService_DeleteRoutine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoutineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineServiceServer).DeleteRoutine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutineService_DeleteRoutine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineServiceServer).DeleteRoutine(ctx, req.(*DeleteRoutineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutineService_AddExerciseToRoutine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddExerciseToRoutineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineServiceServer).AddExerciseToRoutine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutineService_AddExerciseToRoutine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineServiceServer).AddExerciseToRoutine(ctx, req.(*AddExerciseToRoutineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutineService_RemoveExerciseInstanceFromRoutine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveExerciseInstanceFromRoutineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineServiceServer).RemoveExerciseInstanceFromRoutine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutineService_RemoveExerciseInstanceFromRoutine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineServiceServer).RemoveExerciseInstanceFromRoutine(ctx, req.(*RemoveExerciseInstanceFromRoutineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutineService_AddSetToExerciseInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSetToExerciseInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineServiceServer).AddSetToExerciseInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutineService_AddSetToExerciseInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineServiceServer).AddSetToExerciseInstance(ctx, req.(*AddSetToExerciseInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutineService_UpdateSetInExerciseInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSetInExerciseInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineServiceServer).UpdateSetInExerciseInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutineService_UpdateSetInExerciseInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineServiceServer).UpdateSetInExerciseInstance(ctx, req.(*UpdateSetInExerciseInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutineService_RemoveSetFromExerciseInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveSetFromExerciseInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutineServiceServer).RemoveSetFromExerciseInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutineService_RemoveSetFromExerciseInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutineServiceServer).RemoveSetFromExerciseInstance(ctx, req.(*RemoveSetFromExerciseInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RoutineService_ServiceDesc is the grpc.ServiceDesc for RoutineService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoutineService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "fitness_trainer.api.workout.RoutineService",
	HandlerType: (*RoutineServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRoutines",
			Handler:    _RoutineService_GetRoutines_Handler,
		},
		{
			MethodName: "CreateRoutine",
			Handler:    _RoutineService_CreateRoutine_Handler,
		},
		{
			MethodName: "GetRoutineDetail",
			Handler:    _RoutineService_GetRoutineDetail_Handler,
		},
		{
			MethodName: "DeleteRoutine",
			Handler:    _RoutineService_DeleteRoutine_Handler,
		},
		{
			MethodName: "AddExerciseToRoutine",
			Handler:    _RoutineService_AddExerciseToRoutine_Handler,
		},
		{
			MethodName: "RemoveExerciseInstanceFromRoutine",
			Handler:    _RoutineService_RemoveExerciseInstanceFromRoutine_Handler,
		},
		{
			MethodName: "AddSetToExerciseInstance",
			Handler:    _RoutineService_AddSetToExerciseInstance_Handler,
		},
		{
			MethodName: "UpdateSetInExerciseInstance",
			Handler:    _RoutineService_UpdateSetInExerciseInstance_Handler,
		},
		{
			MethodName: "RemoveSetFromExerciseInstance",
			Handler:    _RoutineService_RemoveSetFromExerciseInstance_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "workouts/workouts.proto",
}

const (
	WorkoutService_StartWorkout_FullMethodName          = "/fitness_trainer.api.workout.WorkoutService/StartWorkout"
	WorkoutService_GetWorkout_FullMethodName            = "/fitness_trainer.api.workout.WorkoutService/GetWorkout"
	WorkoutService_GetActiveWorkouts_FullMethodName     = "/fitness_trainer.api.workout.WorkoutService/GetActiveWorkouts"
	WorkoutService_GetWorkouts_FullMethodName           = "/fitness_trainer.api.workout.WorkoutService/GetWorkouts"
	WorkoutService_LogExercise_FullMethodName           = "/fitness_trainer.api.workout.WorkoutService/LogExercise"
	WorkoutService_GetExerciseLogDetails_FullMethodName = "/fitness_trainer.api.workout.WorkoutService/GetExerciseLogDetails"
	WorkoutService_DeleteExerciseLog_FullMethodName     = "/fitness_trainer.api.workout.WorkoutService/DeleteExerciseLog"
	WorkoutService_LogSet_FullMethodName                = "/fitness_trainer.api.workout.WorkoutService/LogSet"
	WorkoutService_CompleteWorkout_FullMethodName       = "/fitness_trainer.api.workout.WorkoutService/CompleteWorkout"
	WorkoutService_GetWorkoutReport_FullMethodName      = "/fitness_trainer.api.workout.WorkoutService/GetWorkoutReport"
	WorkoutService_RateWorkout_FullMethodName           = "/fitness_trainer.api.workout.WorkoutService/RateWorkout"
	WorkoutService_AddCommentToWorkout_FullMethodName   = "/fitness_trainer.api.workout.WorkoutService/AddCommentToWorkout"
)

// WorkoutServiceClient is the client API for WorkoutService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkoutServiceClient interface {
	// Метод для начала новой тренировки
	StartWorkout(ctx context.Context, in *StartWorkoutRequest, opts ...grpc.CallOption) (*WorkoutResponse, error)
	// Метод для получения состояния тренировки
	GetWorkout(ctx context.Context, in *GetWorkoutRequest, opts ...grpc.CallOption) (*GetWorkoutResponse, error)
	// Метод для получения списка активных тренировок
	GetActiveWorkouts(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WorkoutsListResponse, error)
	// Метод для получения списка всех тренировок
	GetWorkouts(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WorkoutsListResponse, error)
	// Метод для создания записи о выполнении упражнения
	LogExercise(ctx context.Context, in *LogExerciseRequest, opts ...grpc.CallOption) (*ExerciseLog, error)
	// Метод для получения записи о выполнении упражнения
	GetExerciseLogDetails(ctx context.Context, in *GetExerciseLogDetailRequest, opts ...grpc.CallOption) (*ExerciseLogResponse, error)
	// Удалить запись о выполнении упражнения
	DeleteExerciseLog(ctx context.Context, in *DeleteExerciseLogRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Метод для создания записи о выполнении подхода
	LogSet(ctx context.Context, in *LogSetRequest, opts ...grpc.CallOption) (*SetLogResponse, error)
	// Метод для завершения тренировки
	CompleteWorkout(ctx context.Context, in *CompleteWorkoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Метод для получения отчета о тренировке
	GetWorkoutReport(ctx context.Context, in *GetWorkoutReportRequest, opts ...grpc.CallOption) (*WorkoutReportResponse, error)
	// Метод для установки оценки тренировки
	RateWorkout(ctx context.Context, in *RateWorkoutRequest, opts ...grpc.CallOption) (*WorkoutResponse, error)
	// Метод для добавления комментария к тренировке
	AddCommentToWorkout(ctx context.Context, in *AddCommentToWorkoutRequest, opts ...grpc.CallOption) (*WorkoutResponse, error)
}

type workoutServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkoutServiceClient(cc grpc.ClientConnInterface) WorkoutServiceClient {
	return &workoutServiceClient{cc}
}

func (c *workoutServiceClient) StartWorkout(ctx context.Context, in *StartWorkoutRequest, opts ...grpc.CallOption) (*WorkoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkoutResponse)
	err := c.cc.Invoke(ctx, WorkoutService_StartWorkout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workoutServiceClient) GetWorkout(ctx context.Context, in *GetWorkoutRequest, opts ...grpc.CallOption) (*GetWorkoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWorkoutResponse)
	err := c.cc.Invoke(ctx, WorkoutService_GetWorkout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workoutServiceClient) GetActiveWorkouts(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WorkoutsListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkoutsListResponse)
	err := c.cc.Invoke(ctx, WorkoutService_GetActiveWorkouts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workoutServiceClient) GetWorkouts(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WorkoutsListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkoutsListResponse)
	err := c.cc.Invoke(ctx, WorkoutService_GetWorkouts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workoutServiceClient) LogExercise(ctx context.Context, in *LogExerciseRequest, opts ...grpc.CallOption) (*ExerciseLog, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExerciseLog)
	err := c.cc.Invoke(ctx, WorkoutService_LogExercise_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workoutServiceClient) GetExerciseLogDetails(ctx context.Context, in *GetExerciseLogDetailRequest, opts ...grpc.CallOption) (*ExerciseLogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExerciseLogResponse)
	err := c.cc.Invoke(ctx, WorkoutService_GetExerciseLogDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workoutServiceClient) DeleteExerciseLog(ctx context.Context, in *DeleteExerciseLogRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WorkoutService_DeleteExerciseLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workoutServiceClient) LogSet(ctx context.Context, in *LogSetRequest, opts ...grpc.CallOption) (*SetLogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetLogResponse)
	err := c.cc.Invoke(ctx, WorkoutService_LogSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workoutServiceClient) CompleteWorkout(ctx context.Context, in *CompleteWorkoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WorkoutService_CompleteWorkout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workoutServiceClient) GetWorkoutReport(ctx context.Context, in *GetWorkoutReportRequest, opts ...grpc.CallOption) (*WorkoutReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkoutReportResponse)
	err := c.cc.Invoke(ctx, WorkoutService_GetWorkoutReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workoutServiceClient) RateWorkout(ctx context.Context, in *RateWorkoutRequest, opts ...grpc.CallOption) (*WorkoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkoutResponse)
	err := c.cc.Invoke(ctx, WorkoutService_RateWorkout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workoutServiceClient) AddCommentToWorkout(ctx context.Context, in *AddCommentToWorkoutRequest, opts ...grpc.CallOption) (*WorkoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkoutResponse)
	err := c.cc.Invoke(ctx, WorkoutService_AddCommentToWorkout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkoutServiceServer is the server API for WorkoutService service.
// All implementations must embed UnimplementedWorkoutServiceServer
// for forward compatibility.
type WorkoutServiceServer interface {
	// Метод для начала новой тренировки
	StartWorkout(context.Context, *StartWorkoutRequest) (*WorkoutResponse, error)
	// Метод для получения состояния тренировки
	GetWorkout(context.Context, *GetWorkoutRequest) (*GetWorkoutResponse, error)
	// Метод для получения списка активных тренировок
	GetActiveWorkouts(context.Context, *emptypb.Empty) (*WorkoutsListResponse, error)
	// Метод для получения списка всех тренировок
	GetWorkouts(context.Context, *emptypb.Empty) (*WorkoutsListResponse, error)
	// Метод для создания записи о выполнении упражнения
	LogExercise(context.Context, *LogExerciseRequest) (*ExerciseLog, error)
	// Метод для получения записи о выполнении упражнения
	GetExerciseLogDetails(context.Context, *GetExerciseLogDetailRequest) (*ExerciseLogResponse, error)
	// Удалить запись о выполнении упражнения
	DeleteExerciseLog(context.Context, *DeleteExerciseLogRequest) (*emptypb.Empty, error)
	// Метод для создания записи о выполнении подхода
	LogSet(context.Context, *LogSetRequest) (*SetLogResponse, error)
	// Метод для завершения тренировки
	CompleteWorkout(context.Context, *CompleteWorkoutRequest) (*emptypb.Empty, error)
	// Метод для получения отчета о тренировке
	GetWorkoutReport(context.Context, *GetWorkoutReportRequest) (*WorkoutReportResponse, error)
	// Метод для установки оценки тренировки
	RateWorkout(context.Context, *RateWorkoutRequest) (*WorkoutResponse, error)
	// Метод для добавления комментария к тренировке
	AddCommentToWorkout(context.Context, *AddCommentToWorkoutRequest) (*WorkoutResponse, error)
	mustEmbedUnimplementedWorkoutServiceServer()
}

// UnimplementedWorkoutServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkoutServiceServer struct{}

func (UnimplementedWorkoutServiceServer) StartWorkout(context.Context, *StartWorkoutRequest) (*WorkoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWorkout not implemented")
}
func (UnimplementedWorkoutServiceServer) GetWorkout(context.Context, *GetWorkoutRequest) (*GetWorkoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkout not implemented")
}
func (UnimplementedWorkoutServiceServer) GetActiveWorkouts(context.Context, *emptypb.Empty) (*WorkoutsListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveWorkouts not implemented")
}
func (UnimplementedWorkoutServiceServer) GetWorkouts(context.Context, *emptypb.Empty) (*WorkoutsListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkouts not implemented")
}
func (UnimplementedWorkoutServiceServer) LogExercise(context.Context, *LogExerciseRequest) (*ExerciseLog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogExercise not implemented")
}
func (UnimplementedWorkoutServiceServer) GetExerciseLogDetails(context.Context, *GetExerciseLogDetailRequest) (*ExerciseLogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExerciseLogDetails not implemented")
}
func (UnimplementedWorkoutServiceServer) DeleteExerciseLog(context.Context, *DeleteExerciseLogRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExerciseLog not implemented")
}
func (UnimplementedWorkoutServiceServer) LogSet(context.Context, *LogSetRequest) (*SetLogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogSet not implemented")
}
func (UnimplementedWorkoutServiceServer) CompleteWorkout(context.Context, *CompleteWorkoutRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompleteWorkout not implemented")
}
func (UnimplementedWorkoutServiceServer) GetWorkoutReport(context.Context, *GetWorkoutReportRequest) (*WorkoutReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkoutReport not implemented")
}
func (UnimplementedWorkoutServiceServer) RateWorkout(context.Context, *RateWorkoutRequest) (*WorkoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RateWorkout not implemented")
}
func (UnimplementedWorkoutServiceServer) AddCommentToWorkout(context.Context, *AddCommentToWorkoutRequest) (*WorkoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCommentToWorkout not implemented")
}
func (UnimplementedWorkoutServiceServer) mustEmbedUnimplementedWorkoutServiceServer() {}
func (UnimplementedWorkoutServiceServer) testEmbeddedByValue()                        {}

// UnsafeWorkoutServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkoutServiceServer will
// result in compilation errors.
type UnsafeWorkoutServiceServer interface {
	mustEmbedUnimplementedWorkoutServiceServer()
}

func RegisterWorkoutServiceServer(s grpc.ServiceRegistrar, srv WorkoutServiceServer) {
	// If the following call pancis, it indicates UnimplementedWorkoutServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WorkoutService_ServiceDesc, srv)
}

func _WorkoutService_StartWorkout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWorkoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkoutServiceServer).StartWorkout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkoutService_StartWorkout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkoutServiceServer).StartWorkout(ctx, req.(*StartWorkoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkoutService_GetWorkout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkoutServiceServer).GetWorkout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkoutService_GetWorkout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkoutServiceServer).GetWorkout(ctx, req.(*GetWorkoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkoutService_GetActiveWorkouts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkoutServiceServer).GetActiveWorkouts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkoutService_GetActiveWorkouts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkoutServiceServer).GetActiveWorkouts(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkoutService_GetWorkouts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkoutServiceServer).GetWorkouts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkoutService_GetWorkouts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkoutServiceServer).GetWorkouts(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkoutService_LogExercise_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogExerciseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkoutServiceServer).LogExercise(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkoutService_LogExercise_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkoutServiceServer).LogExercise(ctx, req.(*LogExerciseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkoutService_GetExerciseLogDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExerciseLogDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkoutServiceServer).GetExerciseLogDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkoutService_GetExerciseLogDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkoutServiceServer).GetExerciseLogDetails(ctx, req.(*GetExerciseLogDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkoutService_DeleteExerciseLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExerciseLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkoutServiceServer).DeleteExerciseLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkoutService_DeleteExerciseLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkoutServiceServer).DeleteExerciseLog(ctx, req.(*DeleteExerciseLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkoutService_LogSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkoutServiceServer).LogSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkoutService_LogSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkoutServiceServer).LogSet(ctx, req.(*LogSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkoutService_CompleteWorkout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteWorkoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkoutServiceServer).CompleteWorkout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkoutService_CompleteWorkout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkoutServiceServer).CompleteWorkout(ctx, req.(*CompleteWorkoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkoutService_GetWorkoutReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkoutReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkoutServiceServer).GetWorkoutReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkoutService_GetWorkoutReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkoutServiceServer).GetWorkoutReport(ctx, req.(*GetWorkoutReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkoutService_RateWorkout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RateWorkoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkoutServiceServer).RateWorkout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkoutService_RateWorkout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkoutServiceServer).RateWorkout(ctx, req.(*RateWorkoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkoutService_AddCommentToWorkout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCommentToWorkoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkoutServiceServer).AddCommentToWorkout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkoutService_AddCommentToWorkout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkoutServiceServer).AddCommentToWorkout(ctx, req.(*AddCommentToWorkoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkoutService_ServiceDesc is the grpc.ServiceDesc for WorkoutService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkoutService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "fitness_trainer.api.workout.WorkoutService",
	HandlerType: (*WorkoutServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartWorkout",
			Handler:    _WorkoutService_StartWorkout_Handler,
		},
		{
			MethodName: "GetWorkout",
			Handler:    _WorkoutService_GetWorkout_Handler,
		},
		{
			MethodName: "GetActiveWorkouts",
			Handler:    _WorkoutService_GetActiveWorkouts_Handler,
		},
		{
			MethodName: "GetWorkouts",
			Handler:    _WorkoutService_GetWorkouts_Handler,
		},
		{
			MethodName: "LogExercise",
			Handler:    _WorkoutService_LogExercise_Handler,
		},
		{
			MethodName: "GetExerciseLogDetails",
			Handler:    _WorkoutService_GetExerciseLogDetails_Handler,
		},
		{
			MethodName: "DeleteExerciseLog",
			Handler:    _WorkoutService_DeleteExerciseLog_Handler,
		},
		{
			MethodName: "LogSet",
			Handler:    _WorkoutService_LogSet_Handler,
		},
		{
			MethodName: "CompleteWorkout",
			Handler:    _WorkoutService_CompleteWorkout_Handler,
		},
		{
			MethodName: "GetWorkoutReport",
			Handler:    _WorkoutService_GetWorkoutReport_Handler,
		},
		{
			MethodName: "RateWorkout",
			Handler:    _WorkoutService_RateWorkout_Handler,
		},
		{
			MethodName: "AddCommentToWorkout",
			Handler:    _WorkoutService_AddCommentToWorkout_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "workouts/workouts.proto",
}

const (
	UserService_CreateUser_FullMethodName = "/fitness_trainer.api.workout.UserService/CreateUser"
	UserService_GetUser_FullMethodName    = "/fitness_trainer.api.workout.UserService/GetUser"
	UserService_GetMe_FullMethodName      = "/fitness_trainer.api.workout.UserService/GetMe"
	UserService_UpdateUser_FullMethodName = "/fitness_trainer.api.workout.UserService/UpdateUser"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	// Метод для создания пользователя
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*UserResponse, error)
	// Метод для получения пользователя по ID
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*UserResponse, error)
	// Метод для получения текущего пользователя
	GetMe(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserResponse, error)
	// Метод для обновления данных пользователя
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UserResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, UserService_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetMe(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, UserService_GetMe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, UserService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	// Метод для создания пользователя
	CreateUser(context.Context, *CreateUserRequest) (*UserResponse, error)
	// Метод для получения пользователя по ID
	GetUser(context.Context, *GetUserRequest) (*UserResponse, error)
	// Метод для получения текущего пользователя
	GetMe(context.Context, *emptypb.Empty) (*UserResponse, error)
	// Метод для обновления данных пользователя
	UpdateUser(context.Context, *UpdateUserRequest) (*UserResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) CreateUser(context.Context, *CreateUserRequest) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) GetUser(context.Context, *GetUserRequest) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServiceServer) GetMe(context.Context, *emptypb.Empty) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMe not implemented")
}
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetMe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetMe(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "fitness_trainer.api.workout.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _UserService_GetUser_Handler,
		},
		{
			MethodName: "GetMe",
			Handler:    _UserService_GetMe_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserService_UpdateUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "workouts/workouts.proto",
}

const (
	AuthService_Login_FullMethodName   = "/fitness_trainer.api.workout.AuthService/Login"
	AuthService_Refresh_FullMethodName = "/fitness_trainer.api.workout.AuthService/Refresh"
	AuthService_Logout_FullMethodName  = "/fitness_trainer.api.workout.AuthService/Logout"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	Refresh(ctx context.Context, in *RefreshRequest, opts ...grpc.CallOption) (*RefreshResponse, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AuthService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) Refresh(ctx context.Context, in *RefreshRequest, opts ...grpc.CallOption) (*RefreshResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshResponse)
	err := c.cc.Invoke(ctx, AuthService_Refresh_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AuthService_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
type AuthServiceServer interface {
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	Refresh(context.Context, *RefreshRequest) (*RefreshResponse, error)
	Logout(context.Context, *LogoutRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAuthServiceServer) Refresh(context.Context, *RefreshRequest) (*RefreshResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (UnimplementedAuthServiceServer) Logout(context.Context, *LogoutRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	// If the following call pancis, it indicates UnimplementedAuthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Refresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Refresh_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Refresh(ctx, req.(*RefreshRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "fitness_trainer.api.workout.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _AuthService_Login_Handler,
		},
		{
			MethodName: "Refresh",
			Handler:    _AuthService_Refresh_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _AuthService_Logout_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "workouts/workouts.proto",
}
